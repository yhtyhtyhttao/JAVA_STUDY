线程死亡
线程会以以下三种方式之一结束，结束后就处于死亡状态：
1.run( )方法执行完成，线程正常结束。
2.线程抛出一个未捕获的Exception或Error.
3.直接调用该线程的stop()方法来结束该线程（容易导致死锁）；

当主线程结束时，其他线程不受任何影响，并不会随之结束。一旦子线程启动之后，他就拥有和主线程相同的地位，不会受主线程的影响。


isAlive
public final boolean isAlive()
测试线程是否处于活动状态。如果线程已经启动且尚未终止，则为活动状态。
返回：
如果该线程处于活动状态（就绪，运行，阻塞），则返回 true；否则（新建，死亡）返回 false。


不要对处于死亡状态的线程调用start()方法，程序只能对新建状态的线程调用start()方法，对新建状态的线程两次调用start()方法也是错误的。

在线程的生命周期中，要经过新建，就绪，运行，阻塞，死亡 五种状态。

注意：
启动线程使用start方法，而不是run方法！永远不要调用线程对象的run方法！调用start方法来启动线程，系统会把该run方法当成线程执行体来处理。但如果直接调用线程对象的run方法，则run方法立即就会被执行，而且在run方法返回之前其他线程无法并发执行----也就是说系统把线程对象当成一个普通对象，而run方法也是一个普通方法，而不是线程执行体。

sleep()方法：
public static void main(String[] args) throws InterruptedException{
		for(int i=0;i<100;i++){
			//调用Thread的currentThread方法获取当前线程
			System.out.println(Thread.currentThread().getName() + " " + i);
			if(i == 20){
				
				//创建并启动第一条线程
				new FirstThread().start();
				//程序调用子线程的start()方法后子线程开始立即执行
				//使用Thread.sleep(1)让当前运行的线程(主线程)睡眠1毫秒
				Thread.sleep(1);
				//创建并启动第二条线程
				new FirstThread().start();
			}
		}
	}

yield()     暂停当前正在执行的线程对象，并执行其他线程。让运行状态的线程转入就绪状态。


当程序使用new关键字创建一个线程后，该线程就处于新建状态
当线程对象调用start()方法后，该线程处于就绪状态
当处于就绪状态的线程获得了CPU，开始执行run方法的线程执行体，则该线程处于运行状态


以下情况线程会进入阻塞状态：
1.线程调用sleep方法主动放弃所占用的处理器资源。
2.线程调用一个阻塞式IO方法，在该方法返回之前，该线程被阻塞。
3.线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。
4.线程在等待某个通知（notify）。
5.程序调用了线程的suspend方法将该线程挂起（容易导致死锁，已过时）。
以下情况会解除线程阻塞，让该线程重新进入就绪状态：
1.调用sleep方法的线程经过了指定的时间。
2.线程调用的阻塞式IO方法已经返回。
3.线程成功获得了试图获取的同步监视器。
4.线程正在等待某个通知时，其他线程发出了一个通知。
5.处于挂起状态的线程被调用了resume（已过时）恢复方法。

